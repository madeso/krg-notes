///////////////////////////////////////////////////////////////////////////////////////////////////
// actuation / execution / action layer
//    move the agent (locomotion, navlinkgs, reactions, smart objects) (with or without combat bool)
//    playing animation(and handling side effecs)
//    triggering audio (barks, reactions)
// can be used for: ai, cinematics, scripting and testing

enum class Result { invalid, active, failed, succeeded };
enum class StopReason { completed, interrupted };

struct Action
{
    virtual void start() = 0;
    virtual Result update() = 0;
    virtual void stop(StopReason reason) = 0; // query action to get the reason for failure (for robustness, debugging, logging)
};

struct MoveToAction : Action
{
    void start() override
    {
        // set up character gameplay & physics state
        // lock to navmesh
        // enable gravity?
        // setup animation state (locomotion state)
        // set up everything... assume nothing
    }

    Result update() override
    {
        if(false == has_path || path_invalidated)
        {
            if(false == try_find_path())
            {
                return Result::failed;
            }
        }

        if(moving_along_path)
        {
            // path following logic
            if(is_within_stopping_distance)
            {
                // trigger stop
            }
        }
        else if(is_stopping)
        {
            if(stop_animation_complete)
            {
                return Result::succeeded;
            }
        }
        else if(is_idle)
        {
            // trigger start
        }

        return Result::active;
    }

    void stop(StopReason) override
    {
        // release path handle
        // trigger stop if we're moving (for failer/interuption)
    }
};

/*
Need to layers for the action system

sequential/primary (full body)
    locomotion (move-to, idle, navlink, jump...)
    reaction (hit, events...)
    attack/interaction (punch, revive, smart object...)
parallel/secondary (upper body/overlay), run across multiple sequential actions
    overlay actions (shooting, reloading, thow...)
    focus/state actions (look-at, injured, scared...)
*/


///////////////////////////////////////////////////////////////////////////////////////////////////
// perception / knowledge


/** ai only representation of the world
 */
struct AiWorld
{
    // agents
    // players
    // visual stim: explosions, dead bodies, blood, character action (reload, punch...)
    // audio stim (footsteps, gunshots, explosion, bark...)
    // enviromental/generic stims (last known position, breadcrumbs, alarms, light columes, aggro auras...)
    // smart objects/interactables/covers
    // global state/behavior modifiers

    // shared tactical state
    // shared information system

    // transfer relevant state to agents

    // runs ai simulation and updates  (updates, sensor updates, scheduling)
};

/** generated by fire and forget function "events" or by scripting turning on/enabling a area "event".
 aka, ai event, ai markup
 */
struct Stim
{
    // type
    // severity/scale (small, medium, large)
    // position
    // lifetime (optional)
    // source agent/object id

    // limit to a location/area
    // lifetime: audio have a timer, visual expire after 1 frame
    // can be restricted to specfic users

    // instant stims can affect decision making
    // esxample: hit reaction/bullet hit, explosions
};

/** what an agent knows of the world, personal/private to the agent
 */
struct Knowledge
{
    // not a blackboard, use a more explicit structure

    // update each 100-150ms reflect current state of the game to agent knowledge
    // run all updates for a agent on a single frame
    // can be run slower than decision update and it's ok if it runs on stale data
};

/** sensors read from from ai world to knowledge
 chage sensors based on scripting or ai state (relaxed/combat sensors, noisy enviroment reduce audio range)
 */
struct VisualSensor
{
    // create knowledge for what the agent can see
    // have a set of local shapes for seeing: (long shape for distance vision, shorter for peropheral vision, one for personal space)
    // combat sensor: large 5 meter shape for "combat vision"

    // checks all registred visual objects in the world agains the shapes
    // objects withing the shapes can be checked for visibility using raycasts (or use navmesh line of sight)
    // raycast to multiple bones (head, chest, elbow, knee) -> any unblocked = visible
};

struct AudioSensor
{
    // distance based?
    // closest point on navmesh
    // use 3d pathfinding?
};

/** Complex/compound knowledge entry: here is all the things you can do (not have to!) + all information to do it.
 Generated by generators ("advanced sensors").
 Why? optimization, debugging (decision is separate from knowledge)
*/
struct Goal;
    // contains bunch of custom data
    // might link to other knowledge entries

    // example: 
    // combat goal: listed of every enemy, everyt combat interactable...
    // investigation: points of interest to search within 10 meters
    // if we had a new gunshot audio stim, we create a react goal with that stim linked
    // if an agent can see enemies, we create a combat goal with all enemy agents
    // if there are available covers near the agent we create a use cover goal with those covers linked


// generate and remove goals each knowledge update
// rule based approach

/** Global shared state.
optimizing longer calculations
Could be used to fake group behavior
*/
struct SharedInformation
{
    // example: stealth search
    // look up search interactions (smart objects/interactables)
    // create a search zone and store status
    // multiple agents can join "the search" and flag objects as "searched"
    // zones are "localized" and agents can find existing or merge zones

    // combat zone
    // share cover information, evaluate positions with cover and line of sight to player
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// decision making

// goal planning: complex hidden logic for designers, hard to debug
// reactive planning: fsm, decision tree, behavior tree, utility selection
// pick closest cover and shoot at player might be comparable to cover evaluation and line of sight eval

enum class ExecutionState { running, completed, failed };

/** sequence of actions that achieve some goal.
example:
 * move to X, play animation
 * move to X while shooting, reloading/etc...
 * play reaction animation Y and audio bark Z
*/
struct Behavior
{
    // has a unique name

    // sequencer for the actuation layer: request action, wait for action...
    // config/settings that control certain aspects (distance to move, speed custom precondition, fire rate, etc...

    // authored in code, behavior tree, blueprint...

    // can be linear.. can also be follow path and use smart objects at control waypoint

    // may or may not be interuptable... bool property

    // must support failure
    // request behaviour via test harness

    virtual ExecutionState update() = 0;
    virtual bool is_interupptable() = 0;

    // has precondition (usually tied to goal... but not always... use path require path...)
    // cooldown
    
    /** can this behavior be started
     */
    bool is_valid_selection_option() const { return is_cooling_down() == false && are_starting_conditions_met(); }

    /** is the behavior currently cooling down
     */
    bool is_cooling_down() const;

    /** are the coditions valid for this behavior to be started
     */
    virtual bool are_starting_conditions_met() const { return true; }

    /** Calculate a score used for behavior selection when we have multiple options.
     dynamically calculated based on situation/settings/etc...
     select the behavior that has the hight score or randomly if all tops are equal
     */
    virtual float calculate_selection_score() const { return 1.0f; }

    /* examples
    melee attack, ranged attack, investigate, chase target, hit reaction, general reaction, search for target, revive target, use smart object
    default behavior to fall back to
    */
};

// behavior reuse: new behavior from other behavior with different options

/** share precondition across multiple behaviors
list of behaviours with shared preconditions
can contain other groups
*/
struct BehaviorGroup
{
    // has a unique name

    // examples: attack(melee, ranged), combat (revive target, chase target, ATTACK), reactions(hit reaction, general reaction), search(iinvestigate, search for target)
    std::vector<BehaviorGroup*> subgroups;
    std::vector<BehaviorGroup*> behaviours;

    void append_behaviors(std::vector<Behavior*>* selected_behaviors) const
    {
        if(are_preconditions_met() == false) { return; }

        for(const auto& group: subgroups)
        {
            group->append_behavior(selected_behaviors);
        }

        for(const auto& beh: behaviors)
        {
            if(beh->is_valid_selection_option())
            {
                selected_behaviors->emplace_back(beh);
            }
        }
    }

    virtual bool are_preconditions_met() const { return true; }
};

// behavior selection:

// basic
// sequence multiple behaviors
// behavior cooldown (I just did this, I don't want to do this again for X time)
// pre conditions
// reuse with different settings

// advanced:
// runtime disabling of existing behaviors
// runtime injection of new behaviors

// many agents
// manager centric (aka director, coordinator) (agents are puppets)
// agent centric (agents decide)
// managers are useful for dumb zombies

// group behavior:
//  covering fire:
//    agent 1
//      if others agents are nearby and cooldown available
//      bark: "cover me"
//      spawn stim volume needs-cover-fire
//      execute a move to
//    agent 2
//      if in needs-cover-fire and needs to shoot (stim zone influence)
//      bark: "covering!"
//      already-shooting? just bark!
//
// mobile cover:
//  attach smart object/mobile cover point to a moving object (or another player with riotshield)
//
// social interactions:
//  smart objects: multiple users of same object (fireplace) that switch actions
//  syncronised animation/paired interaction with dialog and conversation


// ----------------------------------------------------------------------------

// decision making

// what could a agent do? (goal generation)
// what should a agent do? (behavior selection)

// are there any events I want to react to
// are there any objects that I could use
// are there any threats nearby
// are there available covers that I can use

/** Piece of data that defines a "high level thing I can do/use".
 only specify what is available/possible (see enemy, not fight or flee)
 can have hints: there are 5 enemies but the aggro system says target this one or other agents are targeting the other

Examples:
 * follow a patrol (patrol list)
 * use a smart object (smart object list)
 * look at point of interest
 * react to X (list...)
 * fight and enemy
 * shoot an explosive barrel
 * investigate (list...)
*/
struct Goal
{
    float lifetime;
    bool completed = false;

    bool should_be_removed() const { return completed || lifetime <= 0.0f; }
};

// sensor update -> goal generation -> behavior selection
// goal generator convert world/agent knowledge into goals
// generator creates updates and destroys goals
// clear rules:
//      hear 3 footstep event within 5 seconds then generate a investigation goal
//      I can only use high cover since I'm a large character
// might need to be updated:
//      reaction goal for footsteps is updated with explosion
// goals might be time sisitive or get invalidated:
//      Invesigation goal created due to footsteps might time out after X seconds
//      I can no longer see my target
// might get converted into other goals:
//      can't see my target anymore... create search goal

// several goal generators per archetype and goals can have settings
// ambient, reaction, investigation, combat

// don't put decisions in generators, example: cover goal should defne max distance so decision can filter... not "the distance"

// binary broadphase selection, don't select behaviours where preconditions aren't met


void behavior_selection()
{
    // this doesn't consider behaviors that can't beinterruptible

    // behavior reselection:
    // behaviors can be infinite... we might want to switch to a better behavior but not a high prio
    // example triggers: by time (evry X seconds), every time a new goal (of specific type) is created/updated

    Behavior* active_behavior;
    BehaviorGroup behaviors;
    BehaviorGroup high_priority; // (reactions, critical (falling, frozen...) )
    Behavior* default_behavior;

    const auto status = active_behavior->update();

    std::vector<Behavior*> considered_behaviors;
    high_priority.append_behaviors(&considered_behaviors);

    if(status != ExecutionState::running)
    {
        behaviors.append_behaviors(&considered_behaviors);
    }

    if(behaviors.empty() == false)
    {
        Behavior* new_behavior = [&]()
        {
            if(considered_behaviors.empty())
            {
                return default_behavior;
            }
            else if(considered_behaviors.size() == 1)
            {
                return considered_behaviors[0];
            }
            else
            {
                // select random from top behavior
                return nullptr;
            }
        }();

        // stop current behavior (if needed)
        // start new behavior
    }
}

// can add/remove behaviors during runtime

// each behavior/group can be referenced with a path
// can inject new behavior into a existing group

// package a set of modifications, modifications also can change properties of the agent (add/remove tags so more options are available...)

// can stack modifications as "archetypes"
// example: core ai, basic ranged combat, investigation, elite ranged combat

// tool to test stacking packages + imgui tool to visualize behavior selection for an agent

// example usages:
//  simpler archetypes derivation (basic, veteran, elite...)
//  role assignment in multi role situation (waiter, shopkeeper...)
//  boss buff
//  scripted encounter adjustments
